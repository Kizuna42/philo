/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   monitor.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kizuna <kizuna@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/19 00:00:00 by student           #+#    #+#             */
/*   Updated: 2025/05/27 18:54:44 by kizuna           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * ============================================================================
 * MONITOR.C - 監視・チェック機能モジュール
 * ============================================================================
 *
 * このファイルは哲学者の状態を監視し、シミュレーションの終了条件を
 * チェックする機能を提供します。
 *
 * 主な監視項目：
 * 1. 個別哲学者の死亡チェック
 * 2. 全哲学者の死亡状態確認
 * 3. 全哲学者の食事完了チェック
 * 4. 死亡フラグの管理
 *
 * 終了条件：
 * - 誰かが死亡した場合
 * - 全員が必要回数の食事を完了した場合
 *
 * スレッドセーフティ：
 * 全ての状態チェックはmutexで保護されており、
 * 複数スレッドからの同時アクセスに対応しています。
 * ============================================================================
 */

#include "philo.h"

/*
 * ============================================================================
 * philosopher_dead - 個別哲学者の死亡判定
 * ============================================================================
 *
 * 指定された哲学者が死亡したかどうかを判定します。
 * 最後の食事から指定時間が経過し、かつ現在食事中でない場合に死亡と判定します。
 *
 * 引数:
 *   philo: チェックする哲学者の構造体
 *   time_to_die: 死亡までの時間（ミリ秒）
 *
 * 戻り値:
 *   1: 哲学者が死亡している
 *   0: 哲学者は生存している
 *
 * 判定条件:
 *   1. 最後の食事から time_to_die 以上の時間が経過
 *   2. 現在食事中ではない（eating == 0）
 *
 * スレッドセーフティ:
 *   meal_lockを使用して、last_mealとeatingの読み取りを保護します。
 *   これにより、食事中の状態変更との競合を防ぎます。
 * ============================================================================
 */
int	philosopher_dead(t_philo *philo, size_t time_to_die)
{
	pthread_mutex_lock(philo->meal_lock);

	/* 最後の食事から十分な時間が経過し、かつ食事中でない場合 */
	if (get_current_time() - philo->last_meal >= time_to_die
		&& philo->eating == 0)
	{
		pthread_mutex_unlock(philo->meal_lock);
		return (1);  /* 死亡 */
	}

	pthread_mutex_unlock(philo->meal_lock);
	return (0);  /* 生存 */
}

/*
 * ============================================================================
 * check_death_and_set_flag - 死亡チェックとフラグ設定
 * ============================================================================
 *
 * 全ての哲学者をチェックし、死亡者がいた場合は死亡メッセージを出力し、
 * 死亡フラグを設定します。
 *
 * 引数:
 *   philos: 哲学者配列
 *
 * 戻り値:
 *   1: 誰かが死亡した
 *   0: 全員生存している
 *
 * 処理の流れ:
 *   1. 全ての哲学者を順番にチェック
 *   2. 死亡者が見つかった場合：
 *      - 死亡メッセージを出力
 *      - 死亡フラグを設定
 *      - 即座に1を返す
 *   3. 全員生存の場合は0を返す
 *
 * 重要な点:
 *   死亡フラグの設定はdead_lockで保護されており、
 *   他のスレッドからの読み取りと競合しません。
 * ============================================================================
 */
int	check_death_and_set_flag(t_philo *philos)
{
	int	i;

	i = 0;
	while (i < philos[0].num_of_philos)
	{
		/* 個別哲学者の死亡チェック */
		if (philosopher_dead(&philos[i], philos[i].time_to_die))
		{
			/* 死亡メッセージを出力 */
			print_message("died", &philos[i], philos[i].id);

			/* 死亡フラグを安全に設定 */
			pthread_mutex_lock(philos[0].dead_lock);
			*philos->dead = 1;
			pthread_mutex_unlock(philos[0].dead_lock);

			return (1);  /* 死亡者発見 */
		}
		i++;
	}
	return (0);  /* 全員生存 */
}

/*
 * ============================================================================
 * check_if_dead - 死亡フラグの確認
 * ============================================================================
 *
 * 現在の死亡フラグの状態を安全に確認します。
 * 各哲学者スレッドがループを継続するかどうかの判定に使用されます。
 *
 * 引数:
 *   philos: 哲学者配列（フラグアクセス用）
 *
 * 戻り値:
 *   1: 誰かが死亡している（シミュレーション終了）
 *   0: 全員生存している（シミュレーション継続）
 *
 * スレッドセーフティ:
 *   dead_lockを使用して死亡フラグの読み取りを保護します。
 *   複数の哲学者スレッドが同時にこの関数を呼び出しても安全です。
 * ============================================================================
 */
int	check_if_dead(t_philo *philos)
{
	pthread_mutex_lock(philos[0].dead_lock);

	if (*philos->dead == 1)
	{
		pthread_mutex_unlock(philos[0].dead_lock);
		return (1);  /* 死亡フラグが設定されている */
	}

	pthread_mutex_unlock(philos[0].dead_lock);
	return (0);  /* 死亡フラグが設定されていない */
}

/*
 * ============================================================================
 * check_if_all_ate - 全員食事完了チェック
 * ============================================================================
 *
 * 全ての哲学者が必要回数の食事を完了したかをチェックします。
 * 完了した場合は死亡フラグを設定してシミュレーションを終了します。
 *
 * 引数:
 *   philos: 哲学者配列
 *
 * 戻り値:
 *   1: 全員が食事を完了した
 *   0: まだ食事が完了していない哲学者がいる
 *
 * 処理の流れ:
 *   1. 食事回数制限が設定されているかチェック（-1なら無制限）
 *   2. 各哲学者の食事回数をチェック
 *   3. 必要回数に達した哲学者をカウント
 *   4. 全員が完了した場合、死亡フラグを設定
 *
 * スレッドセーフティ:
 *   各哲学者のmeal_lockを使用して食事回数を安全に読み取ります。
 *   最終的な死亡フラグ設定はdead_lockで保護されます。
 * ============================================================================
 */
int	check_if_all_ate(t_philo *philos)
{
	int	i;
	int	finished_eating;

	i = 0;
	finished_eating = 0;

	/* 食事回数制限が設定されていない場合（無制限） */
	if (philos[0].num_times_to_eat == -1)
		return (0);

	/* 各哲学者の食事完了状況をチェック */
	while (i < philos[0].num_of_philos)
	{
		pthread_mutex_lock(philos[i].meal_lock);
		if (philos[i].meals_eaten >= philos[i].num_times_to_eat)
			finished_eating++;  /* 完了した哲学者をカウント */
		pthread_mutex_unlock(philos[i].meal_lock);
		i++;
	}

	/* 全員が食事を完了した場合 */
	if (finished_eating == philos[0].num_of_philos)
	{
		/* 死亡フラグを設定してシミュレーション終了 */
		pthread_mutex_lock(philos[0].dead_lock);
		*philos->dead = 1;
		pthread_mutex_unlock(philos[0].dead_lock);
		return (1);  /* 全員完了 */
	}

	return (0);  /* まだ完了していない */
}
