/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   actions.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kizuna <kizuna@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/19 00:00:00 by student           #+#    #+#             */
/*   Updated: 2025/05/27 18:53:34 by kizuna           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * ============================================================================
 * ACTIONS.C - 哲学者の行動実装モジュール
 * ============================================================================
 *
 * このファイルは哲学者が行う各種行動を実装しています。
 * 哲学者問題における基本的な行動パターン：
 *
 * 1. フォークを取る（take_forks）
 * 2. 食事をする（eat）
 * 3. フォークを置く（drop_forks）
 * 4. 睡眠する（philo_sleep）
 * 5. 思考する（think）
 *
 * 重要な考慮事項：
 * - デッドロック回避（フォークの取得順序）
 * - 1人の哲学者の特別処理
 * - 食事時間の正確な管理
 * - スレッドセーフな状態更新
 * ============================================================================
 */

#include "philo.h"

/*
 * ============================================================================
 * take_forks - フォークを取得する
 * ============================================================================
 *
 * 哲学者が食事をするために必要な2本のフォークを取得します。
 * 右のフォークを先に取り、次に左のフォークを取ります。
 *
 * 引数:
 *   philo: 行動する哲学者の構造体
 *
 * 特別なケース:
 *   哲学者が1人の場合、フォークが1本しかないため食事できません。
 *   この場合、死亡時間まで待機してからフォークを解放します。
 *
 * デッドロック回避:
 *   全ての哲学者が同じ順序（右→左）でフォークを取ることで、
 *   循環待機を防ぎます。
 *
 * 処理の流れ:
 *   1. 右のフォーク（mutex）をロック
 *   2. フォーク取得メッセージを出力
 *   3. 1人の場合は特別処理
 *   4. 左のフォーク（mutex）をロック
 *   5. 2本目のフォーク取得メッセージを出力
 * ============================================================================
 */
void	take_forks(t_philo *philo)
{
	/* 右のフォークを取得 */
	pthread_mutex_lock(philo->r_fork);
	print_message("has taken a fork", philo, philo->id);

	/* 1人の哲学者の特別処理 */
	if (philo->num_of_philos == 1)
	{
		/* フォークが1本しかないので食事できない */
		/* 死亡時間まで待機してから終了 */
		ft_usleep(philo->time_to_die);
		pthread_mutex_unlock(philo->r_fork);
		return ;
	}

	/* 左のフォークを取得 */
	pthread_mutex_lock(philo->l_fork);
	print_message("has taken a fork", philo, philo->id);
}

/*
 * ============================================================================
 * eat - 食事を行う
 * ============================================================================
 *
 * 哲学者の食事プロセス全体を管理します。
 * フォークの取得から食事の実行、フォークの解放まで一連の処理を行います。
 *
 * 引数:
 *   philo: 食事する哲学者の構造体
 *
 * 処理の流れ:
 *   1. フォークを取得
 *   2. 食事状態フラグを設定
 *   3. 食事開始メッセージを出力
 *   4. 最後の食事時刻を更新（スレッドセーフ）
 *   5. 食事回数をインクリメント
 *   6. 食事時間だけ待機
 *   7. 食事状態フラグをクリア
 *   8. フォークを解放
 *
 * スレッドセーフティ:
 *   meal_lockを使用して、last_mealとmeals_eatenの更新を保護します。
 *   これにより監視スレッドとの競合状態を防ぎます。
 * ============================================================================
 */
void	eat(t_philo *philo)
{
	/* フォークを取得 */
	take_forks(philo);

	/* 1人の場合は食事できないので終了 */
	if (philo->num_of_philos == 1)
		return ;

	/* 食事状態に設定 */
	philo->eating = 1;
	print_message("is eating", philo, philo->id);

	/* 食事関連データを安全に更新 */
	pthread_mutex_lock(philo->meal_lock);
	philo->last_meal = get_current_time();  /* 最後の食事時刻を記録 */
	philo->meals_eaten++;                   /* 食事回数をインクリメント */
	pthread_mutex_unlock(philo->meal_lock);

	/* 食事時間だけ待機 */
	ft_usleep(philo->time_to_eat);

	/* 食事完了 */
	philo->eating = 0;

	/* フォークを解放 */
	drop_forks(philo);
}

/*
 * ============================================================================
 * drop_forks - フォークを解放する
 * ============================================================================
 *
 * 食事完了後に2本のフォークを解放します。
 * 他の哲学者がフォークを使用できるようになります。
 *
 * 引数:
 *   philo: フォークを解放する哲学者の構造体
 *
 * 処理:
 *   左のフォーク、右のフォークの順でmutexをアンロックします。
 *   取得時とは逆の順序で解放することで、デッドロックを防ぎます。
 * ============================================================================
 */
void	drop_forks(t_philo *philo)
{
	pthread_mutex_unlock(philo->l_fork);  /* 左のフォークを解放 */
	pthread_mutex_unlock(philo->r_fork);  /* 右のフォークを解放 */
}

/*
 * ============================================================================
 * philo_sleep - 睡眠を行う
 * ============================================================================
 *
 * 哲学者が食事後に行う睡眠です。
 * 指定された睡眠時間だけプログラムを一時停止します。
 *
 * 引数:
 *   philo: 睡眠する哲学者の構造体
 *
 * 処理:
 *   1. 睡眠開始メッセージを出力
 *   2. 指定された睡眠時間だけ待機
 *
 * 注意:
 *   睡眠中も監視スレッドは動作しており、死亡チェックが行われます。
 * ============================================================================
 */
void	philo_sleep(t_philo *philo)
{
	print_message("is sleeping", philo, philo->id);
	ft_usleep(philo->time_to_sleep);
}

/*
 * ============================================================================
 * think - 思考を行う
 * ============================================================================
 *
 * 哲学者が睡眠後に行う思考です。
 * 実際の待機時間はなく、メッセージの出力のみを行います。
 *
 * 引数:
 *   philo: 思考する哲学者の構造体
 *
 * 処理:
 *   思考開始メッセージを出力するのみ
 *
 * 設計上の考慮:
 *   思考時間を設けないことで、哲学者は可能な限り早く
 *   次の食事サイクルに入ることができます。
 *   これにより、より多くの食事機会を確保できます。
 * ============================================================================
 */
void	think(t_philo *philo)
{
	print_message("is thinking", philo, philo->id);
}
