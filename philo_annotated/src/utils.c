/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kizuna <kizuna@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/19 00:00:00 by student           #+#    #+#             */
/*   Updated: 2025/05/27 18:50:26 by kizuna           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * ============================================================================
 * UTILS.C - ユーティリティ関数群
 * ============================================================================
 *
 * このファイルは哲学者プログラムで使用される基本的なユーティリティ関数を
 * 提供します。標準ライブラリの関数を再実装したものや、時間処理に特化した
 * 関数が含まれています。
 *
 * 含まれる関数：
 * - ft_atoi: 文字列を整数に変換
 * - ft_isdigit: 文字が数字かどうか判定
 * - ft_strlen: 文字列の長さを取得
 * - get_current_time: 現在時刻をミリ秒で取得
 * - ft_usleep: 精密なスリープ機能
 *
 * これらの関数は哲学者問題の時間管理や入力処理において重要な役割を果たします。
 * ============================================================================
 */

#include "philo.h"

/*
 * ============================================================================
 * ft_atoi - 文字列を整数に変換
 * ============================================================================
 *
 * 標準ライブラリのatoi関数の再実装です。
 * 文字列の先頭から数字を読み取り、整数値に変換します。
 *
 * 引数:
 *   str: 変換する文字列
 *
 * 戻り値:
 *   変換された整数値
 *
 * 処理の流れ:
 *   1. 先頭の空白文字をスキップ
 *   2. 符号（+/-）を処理
 *   3. 数字文字を順次処理して整数値を構築
 *
 * 注意:
 *   オーバーフローのチェックは行っていません。
 *   哲学者問題では比較的小さな値のみを扱うため、簡略化されています。
 * ============================================================================
 */
int	ft_atoi(const char *str)
{
	int	result;
	int	sign;
	int	i;

	result = 0;
	sign = 1;
	i = 0;

	/* 先頭の空白文字（スペース、タブ、改行など）をスキップ */
	while (str[i] == ' ' || str[i] == '\t' || str[i] == '\n'
		|| str[i] == '\v' || str[i] == '\f' || str[i] == '\r')
		i++;

	/* 符号の処理（+または-） */
	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}

	/* 数字文字を順次処理して整数値を構築 */
	while (str[i] >= '0' && str[i] <= '9')
	{
		result = result * 10 + (str[i] - '0');
		i++;
	}

	return (result * sign);
}

/*
 * ============================================================================
 * ft_isdigit - 文字が数字かどうか判定
 * ============================================================================
 *
 * 指定された文字が数字（0-9）かどうかを判定します。
 * 入力検証で使用され、引数が数字のみで構成されているかをチェックします。
 *
 * 引数:
 *   c: 判定する文字（int型だが実際は文字コード）
 *
 * 戻り値:
 *   1: 文字が数字（0-9）
 *   0: 文字が数字以外
 *
 * 使用例:
 *   if (ft_isdigit('5')) // 1を返す
 *   if (ft_isdigit('a')) // 0を返す
 * ============================================================================
 */
int	ft_isdigit(int c)
{
	return (c >= '0' && c <= '9');
}

/*
 * ============================================================================
 * ft_strlen - 文字列の長さを取得
 * ============================================================================
 *
 * 標準ライブラリのstrlen関数の再実装です。
 * 文字列の終端（'\0'）まで文字数をカウントします。
 *
 * 引数:
 *   s: 長さを測定する文字列
 *
 * 戻り値:
 *   文字列の長さ（終端文字は含まない）
 *
 * 注意:
 *   NULLポインタのチェックは行っていません。
 *   呼び出し側で有効な文字列を渡すことを前提としています。
 * ============================================================================
 */
int	ft_strlen(const char *s)
{
	int	len;

	len = 0;
	while (s[len])
		len++;
	return (len);
}

/*
 * ============================================================================
 * get_current_time - 現在時刻をミリ秒で取得
 * ============================================================================
 *
 * システムの現在時刻をミリ秒単位で取得します。
 * 哲学者問題では時間の管理が重要なため、この関数が頻繁に使用されます。
 *
 * 戻り値:
 *   現在時刻（ミリ秒）
 *
 * 実装詳細:
 *   - gettimeofday()システムコールを使用
 *   - 秒をミリ秒に変換（×1000）
 *   - マイクロ秒をミリ秒に変換（÷1000）
 *
 * エラーハンドリング:
 *   gettimeofday()が失敗した場合、エラーメッセージを出力しますが
 *   プログラムは継続します。
 * ============================================================================
 */
size_t	get_current_time(void)
{
	struct timeval	time;

	if (gettimeofday(&time, NULL) == -1)
		write(2, "gettimeofday() error\n", 22);

	/* 秒をミリ秒に変換し、マイクロ秒をミリ秒に変換して加算 */
	return (time.tv_sec * 1000 + time.tv_usec / 1000);
}

/*
 * ============================================================================
 * ft_usleep - 精密なスリープ機能
 * ============================================================================
 *
 * 指定されたミリ秒数だけプログラムを一時停止します。
 * 標準のusleep()よりも精密で、指定時間ちょうどに復帰することを目指します。
 *
 * 引数:
 *   milliseconds: スリープする時間（ミリ秒）
 *
 * 戻り値:
 *   常に0（成功）
 *
 * 実装詳細:
 *   - 開始時刻を記録
 *   - 500マイクロ秒ずつusleep()を呼び出し
 *   - 経過時間をチェックして指定時間に達するまで繰り返し
 *
 * なぜこの実装？:
 *   - usleep()は指定時間より長くスリープすることがある
 *   - 短い間隔で時間をチェックすることで、より精密な制御を実現
 *   - 哲学者問題では正確なタイミングが重要
 * ============================================================================
 */
int	ft_usleep(size_t milliseconds)
{
	size_t	start;

	start = get_current_time();

	/* 指定時間が経過するまで短いスリープを繰り返す */
	while ((get_current_time() - start) < milliseconds)
		usleep(500);

	return (0);
}
