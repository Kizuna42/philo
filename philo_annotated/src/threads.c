/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   threads.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kizuna <kizuna@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/19 00:00:00 by student           #+#    #+#             */
/*   Updated: 2025/05/27 18:53:34 by kizuna           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * ============================================================================
 * THREADS.C - スレッド管理モジュール
 * ============================================================================
 *
 * このファイルは哲学者問題におけるスレッドの作成、管理、実行を担当します。
 * 主に以下の機能を提供します：
 *
 * 1. 哲学者スレッドの作成と管理
 * 2. 監視スレッドの作成と管理
 * 3. 各哲学者の行動ルーチン
 * 4. 死亡・完了監視ルーチン
 *
 * スレッド構成：
 * - 監視スレッド（observer）: 1つ - 死亡や完了をチェック
 * - 哲学者スレッド: N個 - 各哲学者の行動を実行
 *
 * 同期メカニズム：
 * - mutex（フォーク、出力、状態管理）
 * - 定期的な状態チェック
 * ============================================================================
 */

#include "philo.h"

/*
 * ============================================================================
 * thread_create - スレッド作成と管理のメイン関数
 * ============================================================================
 *
 * 全ての必要なスレッドを作成し、実行完了まで管理します。
 * 監視スレッドを最初に作成し、その後各哲学者スレッドを作成します。
 *
 * 引数:
 *   program: プログラム全体の状態を管理する構造体
 *   forks: フォーク（mutex）の配列
 *
 * 戻り値:
 *   0: 正常終了
 *   エラー時はdestroy_all()を呼び出してプログラム終了
 *
 * 処理の流れ:
 *   1. 監視スレッド作成
 *   2. 全哲学者スレッド作成
 *   3. 監視スレッド終了待ち
 *   4. 全哲学者スレッド終了待ち
 *
 * 注意:
 *   監視スレッドが先に終了することで、全哲学者スレッドも終了します。
 * ============================================================================
 */
int	thread_create(t_program *program, pthread_mutex_t *forks)
{
	pthread_t	observer;
	int			i;

	/* 監視スレッドを作成（死亡・完了チェック用） */
	if (pthread_create(&observer, NULL, &monitor, program->philos) != 0)
		destroy_all("Thread creation error", program, forks);

	/* 全ての哲学者スレッドを作成 */
	i = 0;
	while (i < program->philos[0].num_of_philos)
	{
		if (pthread_create(&program->philos[i].thread, NULL,
				&philo_routine, &program->philos[i]) != 0)
			destroy_all("Thread creation error", program, forks);
		i++;
	}

	/* 監視スレッドの終了を待つ */
	i = 0;
	if (pthread_join(observer, NULL) != 0)
		destroy_all("Thread join error", program, forks);

	/* 全ての哲学者スレッドの終了を待つ */
	while (i < program->philos[0].num_of_philos)
	{
		if (pthread_join(program->philos[i].thread, NULL) != 0)
			destroy_all("Thread join error", program, forks);
		i++;
	}

	return (0);
}

/*
 * ============================================================================
 * philo_routine - 各哲学者スレッドのメインルーチン
 * ============================================================================
 *
 * 各哲学者が実行する行動パターンを定義します。
 * 死亡フラグがセットされるまで、食事→睡眠→思考のサイクルを繰り返します。
 *
 * 引数:
 *   pointer: 哲学者構造体へのポインタ（void*でキャスト）
 *
 * 戻り値:
 *   pointer: 受け取ったポインタをそのまま返す
 *
 * 処理の流れ:
 *   1. 偶数番号の哲学者は1ms待機（デッドロック回避）
 *   2. 死亡フラグがセットされるまでループ
 *   3. 食事→睡眠→思考のサイクルを実行
 *
 * デッドロック回避:
 *   偶数番号の哲学者を少し遅らせることで、全員が同時に
 *   左のフォークを取ろうとする状況を回避します。
 * ============================================================================
 */
void	*philo_routine(void *pointer)
{
	t_philo	*philo;

	philo = (t_philo *)pointer;

	/* 偶数番号の哲学者は少し待機（デッドロック回避） */
	if (philo->id % 2 == 0)
		ft_usleep(1);

	/* 死亡フラグがセットされるまで行動を繰り返す */
	while (!check_if_dead(philo))
	{
		eat(philo);         /* 食事 */
		philo_sleep(philo); /* 睡眠 */
		think(philo);       /* 思考 */
	}

	return (pointer);
}

/*
 * ============================================================================
 * monitor - 監視スレッドのルーチン
 * ============================================================================
 *
 * 全哲学者の状態を監視し、以下の条件をチェックします：
 * 1. 誰かが死亡したか
 * 2. 全員が必要回数食事を完了したか
 *
 * 引数:
 *   pointer: 哲学者配列へのポインタ（void*でキャスト）
 *
 * 戻り値:
 *   pointer: 受け取ったポインタをそのまま返す
 *
 * 処理の流れ:
 *   1. 無限ループで監視を継続
 *   2. 死亡チェックと食事完了チェックを実行
 *   3. いずれかの条件が満たされたらループを抜ける
 *
 * 終了条件:
 *   - 誰かが死亡した場合
 *   - 全員が必要回数の食事を完了した場合
 *
 * 注意:
 *   この監視スレッドが終了すると、メインスレッドが
 *   pthread_join()から復帰し、プログラム全体が終了します。
 * ============================================================================
 */
void	*monitor(void *pointer)
{
	t_philo	*philos;

	philos = (t_philo *)pointer;

	/* 終了条件が満たされるまで監視を継続 */
	while (1)
	{
		/* 死亡チェックまたは全員食事完了チェック */
		if (check_death_and_set_flag(philos) || check_if_all_ate(philos))
			break ;
	}

	return (pointer);
}
