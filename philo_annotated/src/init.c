/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kizuna <kizuna@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/19 00:00:00 by student           #+#    #+#             */
/*   Updated: 2025/05/27 18:58:03 by kizuna           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * ============================================================================
 * INIT.C - 初期化モジュール
 * ============================================================================
 *
 * このファイルは哲学者問題シミュレーションの初期化処理を担当します。
 * プログラム実行前に必要な全ての構造体、mutex、データの初期化を行います。
 *
 * 初期化の対象：
 * 1. プログラム構造体（共有リソース管理）
 * 2. フォーク用mutex（哲学者数分）
 * 3. 哲学者構造体（個別の状態とパラメータ）
 * 4. フォークの割り当て（左右の関係）
 *
 * 重要な考慮事項：
 * - 円卓の配置（最後の哲学者と最初の哲学者が隣接）
 * - 各哲学者への適切なmutexポインタの設定
 * - 時間パラメータの正確な設定
 * ============================================================================
 */

#include "philo.h"

/*
 * ============================================================================
 * init_program - プログラム構造体の初期化
 * ============================================================================
 *
 * プログラム全体で共有されるリソースと状態を初期化します。
 * 全ての共有mutexを作成し、初期状態を設定します。
 *
 * 引数:
 *   program: 初期化するプログラム構造体
 *   philos: 哲学者配列へのポインタ
 *
 * 初期化項目:
 *   - dead_flag: 死亡フラグを0（誰も死んでいない）に設定
 *   - philos: 哲学者配列へのポインタを設定
 *   - dead_lock: 死亡フラグ保護用mutexを初期化
 *   - meal_lock: 食事データ保護用mutexを初期化
 *   - write_lock: 出力保護用mutexを初期化
 *
 * 注意:
 *   mutexの初期化に失敗した場合のエラーハンドリングは
 *   簡略化されています。実際の本格的なプログラムでは
 *   より詳細なエラーチェックが必要です。
 * ============================================================================
 */
void	init_program(t_program *program, t_philo *philos)
{
	program->dead_flag = 0;        /* 初期状態：誰も死んでいない */
	program->philos = philos;      /* 哲学者配列への参照を設定 */

	/* 共有リソース保護用のmutexを初期化 */
	pthread_mutex_init(&program->dead_lock, NULL);   /* 死亡フラグ用 */
	pthread_mutex_init(&program->meal_lock, NULL);   /* 食事データ用 */
	pthread_mutex_init(&program->write_lock, NULL);  /* 出力用 */
}

/*
 * ============================================================================
 * init_forks - フォーク用mutexの初期化
 * ============================================================================
 *
 * 各フォークに対応するmutexを初期化します。
 * 哲学者の数だけフォークが必要なため、同じ数のmutexを作成します。
 *
 * 引数:
 *   forks: フォーク用mutex配列
 *   philo_num: 哲学者の数（＝フォークの数）
 *
 * 処理:
 *   0番から(philo_num-1)番まで、各フォーク用のmutexを初期化します。
 *
 * フォークとmutexの関係:
 *   各フォークは1つのmutexで保護され、同時に1人の哲学者のみが
 *   そのフォークを使用できます。これにより、フォークの競合を防ぎます。
 * ============================================================================
 */
void	init_forks(pthread_mutex_t *forks, int philo_num)
{
	int	i;

	i = 0;
	while (i < philo_num)
	{
		pthread_mutex_init(&forks[i], NULL);  /* 各フォーク用mutexを初期化 */
		i++;
	}
}

/*
 * ============================================================================
 * assign_forks - 哲学者へのフォーク割り当て
 * ============================================================================
 *
 * 各哲学者に左右のフォークを割り当てます。
 * 円卓の配置を考慮し、最後の哲学者と最初の哲学者が隣接するよう設定します。
 *
 * 引数:
 *   philo: フォークを割り当てる哲学者
 *   forks: フォーク用mutex配列
 *   i: 哲学者のインデックス（0から開始）
 *
 * 割り当てルール:
 *   - 左のフォーク: 自分のインデックスと同じ番号
 *   - 右のフォーク:
 *     * 0番の哲学者の場合: 最後のフォーク（円卓の特性）
 *     * その他の場合: (自分のインデックス - 1)番のフォーク
 *
 * 円卓の配置例（5人の場合）:
 *   哲学者0: 左=フォーク0, 右=フォーク4
 *   哲学者1: 左=フォーク1, 右=フォーク0
 *   哲学者2: 左=フォーク2, 右=フォーク1
 *   ...
 * ============================================================================
 */
static void	assign_forks(t_philo *philo, pthread_mutex_t *forks, int i)
{
	int	philo_num;

	philo_num = philo->num_of_philos;

	/* 左のフォークは自分のインデックスと同じ */
	philo->l_fork = &forks[i];

	/* 右のフォークの割り当て（円卓の特性を考慮） */
	if (i == 0)
		philo->r_fork = &forks[philo_num - 1];  /* 0番は最後のフォークが右 */
	else
		philo->r_fork = &forks[i - 1];          /* その他は前のフォークが右 */
}

/*
 * ============================================================================
 * init_philos - 哲学者構造体の初期化
 * ============================================================================
 *
 * 全ての哲学者の構造体を初期化し、必要なパラメータを設定します。
 * コマンドライン引数から時間パラメータを取得し、各哲学者に設定します。
 *
 * 引数:
 *   philos: 初期化する哲学者配列
 *   program: プログラム構造体（共有リソースへの参照用）
 *   forks: フォーク用mutex配列
 *   argv: コマンドライン引数
 *
 * 初期化項目:
 *   - id: 哲学者の識別番号（1から開始）
 *   - eating: 食事状態フラグ（初期値0）
 *   - meals_eaten: 食事回数（初期値0）
 *   - start_time: プログラム開始時刻
 *   - last_meal: 最後の食事時刻（開始時刻と同じ）
 *   - 時間パラメータ: argv[2-4]から取得
 *   - num_times_to_eat: argv[5]から取得（省略時は-1）
 *   - 共有リソースへのポインタ設定
 *   - フォークの割り当て
 *
 * 重要な点:
 *   全ての哲学者が同じ開始時刻を持つことで、
 *   時間計算の基準が統一されます。
 * ============================================================================
 */
void	init_philos(t_philo *philos, t_program *program,
			pthread_mutex_t *forks, char **argv)
{
	int	i;

	i = 0;
	while (i < ft_atoi(argv[1]))
	{
		/* 基本情報の設定 */
		philos[i].id = i + 1;                    /* ID（1から開始） */
		philos[i].eating = 0;                    /* 初期状態：食事していない */
		philos[i].meals_eaten = 0;               /* 食事回数：0回 */

		/* 時間関連の設定 */
		philos[i].start_time = get_current_time();     /* プログラム開始時刻 */
		philos[i].last_meal = get_current_time();      /* 最後の食事時刻 */
		philos[i].time_to_die = ft_atoi(argv[2]);      /* 死亡までの時間 */
		philos[i].time_to_eat = ft_atoi(argv[3]);      /* 食事時間 */
		philos[i].time_to_sleep = ft_atoi(argv[4]);    /* 睡眠時間 */

		/* プログラム設定 */
		philos[i].num_of_philos = ft_atoi(argv[1]);    /* 哲学者の総数 */

		/* 食事回数制限の設定（オプション） */
		if (argv[5])
			philos[i].num_times_to_eat = ft_atoi(argv[5]);  /* 制限あり */
		else
			philos[i].num_times_to_eat = -1;                /* 無制限 */

		/* 共有リソースへのポインタ設定 */
		philos[i].dead = &program->dead_flag;        /* 死亡フラグ */
		philos[i].write_lock = &program->write_lock; /* 出力用mutex */
		philos[i].dead_lock = &program->dead_lock;   /* 死亡フラグ用mutex */
		philos[i].meal_lock = &program->meal_lock;   /* 食事データ用mutex */

		/* フォークの割り当て */
		assign_forks(&philos[i], forks, i);

		i++;
	}
}
