/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kizuna <kizuna@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/19 00:00:00 by student           #+#    #+#             */
/*   Updated: 2025/05/27 18:54:44 by kizuna           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
 * ============================================================================
 * UTILS2.C - 追加ユーティリティ関数群
 * ============================================================================
 *
 * このファイルは哲学者プログラムで使用される補助的な機能を提供します。
 * 主に以下の機能が含まれています：
 *
 * 1. スレッドセーフなメッセージ出力
 * 2. 文字列比較機能
 * 3. リソースの解放とクリーンアップ
 *
 * これらの関数は、プログラムの安全性と正確性を保つために重要な役割を
 * 果たしています。特に、複数スレッド環境での出力制御と、プログラム終了時の
 * 適切なリソース管理を担当しています。
 * ============================================================================
 */

#include "philo.h"

/*
 * ============================================================================
 * print_message - スレッドセーフなメッセージ出力
 * ============================================================================
 *
 * 哲学者の行動や状態変化を安全に出力します。
 * 複数のスレッドが同時に出力しようとしても、メッセージが混在しないよう
 * mutexで保護されています。
 *
 * 引数:
 *   str: 出力するメッセージ文字列
 *   philo: メッセージを出力する哲学者の構造体
 *   id: 哲学者のID
 *
 * 出力フォーマット:
 *   [時刻] [哲学者ID] [メッセージ]
 *   例: "150 3 is eating"
 *
 * 特別な処理:
 *   - "died"メッセージは死亡フラグに関係なく必ず出力
 *   - その他のメッセージは死亡フラグが立っていない場合のみ出力
 *
 * スレッドセーフティ:
 *   - write_lockで出力全体を保護
 *   - dead_lockで死亡フラグの確認を保護
 * ============================================================================
 */
void	print_message(char *str, t_philo *philo, int id)
{
	size_t	time;

	/* 出力全体をロックして保護 */
	pthread_mutex_lock(philo->write_lock);

	/* プログラム開始からの経過時間を計算 */
	time = get_current_time() - philo->start_time;

	/* 死亡メッセージは常に出力 */
	if (ft_strcmp(str, "died") == 0)
	{
		printf("%zu %d %s\n", time, id, str);
		pthread_mutex_unlock(philo->write_lock);
		return ;
	}

	/* その他のメッセージは死亡フラグをチェック */
	pthread_mutex_lock(philo->dead_lock);
	if (*philo->dead == 0)  /* 誰も死んでいない場合のみ出力 */
		printf("%zu %d %s\n", time, id, str);
	pthread_mutex_unlock(philo->dead_lock);

	pthread_mutex_unlock(philo->write_lock);
}

/*
 * ============================================================================
 * ft_strcmp - 文字列比較関数
 * ============================================================================
 *
 * 標準ライブラリのstrcmp関数の再実装です。
 * 2つの文字列を比較し、辞書順での大小関係を返します。
 *
 * 引数:
 *   s1: 比較する文字列1
 *   s2: 比較する文字列2
 *
 * 戻り値:
 *   0: 文字列が等しい
 *   正の値: s1 > s2（辞書順）
 *   負の値: s1 < s2（辞書順）
 *
 * 実装:
 *   文字を1つずつ比較し、異なる文字が見つかった時点で
 *   その文字コードの差を返します。
 *
 * 使用例:
 *   print_message関数内で"died"メッセージの判定に使用
 * ============================================================================
 */
int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	i = 0;
	/* 文字が同じ間は継続 */
	while (s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
		i++;

	/* 異なる文字の差を返す */
	return (s1[i] - s2[i]);
}

/*
 * ============================================================================
 * destroy_all - 全リソースの解放とクリーンアップ
 * ============================================================================
 *
 * プログラム終了時に全てのmutexを適切に破棄し、リソースを解放します。
 * エラーが発生した場合はエラーメッセージを出力して即座に終了します。
 *
 * 引数:
 *   str: エラーメッセージ（NULLの場合は正常終了）
 *   program: プログラム構造体
 *   forks: フォーク（mutex）の配列
 *
 * 処理の流れ:
 *   1. エラーメッセージがある場合は出力して終了
 *   2. プログラム用のmutexを破棄
 *   3. 全てのフォーク用mutexを破棄
 *
 * 破棄するmutex:
 *   - write_lock: 出力保護用
 *   - dead_lock: 死亡フラグ保護用
 *   - meal_lock: 食事データ保護用
 *   - forks[]: 各フォーク用（哲学者数分）
 *
 * 重要性:
 *   mutexの適切な破棄はメモリリークを防ぎ、
 *   システムリソースを正しく解放するために必要です。
 * ============================================================================
 */
void	destroy_all(char *str, t_program *program, pthread_mutex_t *forks)
{
	int	i;

	i = 0;

	/* エラーメッセージがある場合は出力して終了 */
	if (str)
	{
		printf("%s\n", str);
		return ;
	}

	/* プログラム用mutexの破棄 */
	pthread_mutex_destroy(&program->write_lock);
	pthread_mutex_destroy(&program->dead_lock);
	pthread_mutex_destroy(&program->meal_lock);

	/* 全てのフォーク用mutexの破棄 */
	while (i < program->philos[0].num_of_philos)
	{
		pthread_mutex_destroy(&forks[i]);
		i++;
	}
}
